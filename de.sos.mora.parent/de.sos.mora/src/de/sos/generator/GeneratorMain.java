/*
 * generated by Xtext 2.19.0
 */
package de.sos.generator;

import java.io.File;
import java.io.FileFilter;
import java.util.List;

import org.apache.commons.cli.BasicParser;
import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.Option;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.xtext.generator.GeneratorContext;
import org.eclipse.xtext.generator.JavaIoFileSystemAccess;
import org.eclipse.xtext.util.CancelIndicator;
import org.eclipse.xtext.validation.CheckMode;
import org.eclipse.xtext.validation.IResourceValidator;
import org.eclipse.xtext.validation.Issue;

import com.google.inject.Inject;
import com.google.inject.Injector;
import com.google.inject.Provider;

import de.sos.MORAStandaloneSetup;
import de.sos.generator.cpp.CppGenerator;
import de.sos.generator.cpp.CppPlainGenerator;
import de.sos.generator.csharp.CSharpGenerator;
import de.sos.generator.csharp.CSharpGenerator.CSharpOptions;
import de.sos.generator.java.JavaGenerator;

public class GeneratorMain {


	public static void main(String[] args) {
		Options opt = createOptions();
		CommandLineParser parser = new BasicParser();
		try {
			if (args.length == 0) {
				HelpFormatter f = new HelpFormatter();
				f.printHelp("Usage MORA generator <options> [FILE].mora", opt);
				return ;
			}
			CommandLine cmd = parser.parse(opt, args);
			if (cmd.hasOption("h")) {
				HelpFormatter f = new HelpFormatter();
				f.printHelp("Usage MORA generator <options> [FILE].mora", opt);
				return ;
			}
			
			if (cmd.hasOption("j") || cmd.hasOption("cs") || cmd.hasOption("cpp") || cmd.hasOption("plain_cpp")) {
				
				File file = new File(args[args.length-1]);
				if (file.exists() == false) {
					System.err.println("Argument: " + args[args.length-1] + " is not a valid file");
					return ;
				}
				
				Injector injector = new MORAStandaloneSetup().createInjectorAndDoEMFRegistration();
				GeneratorMain main = injector.getInstance(GeneratorMain.class);
				main.runGenerator(file, cmd);		
				
			}else {
				System.err.println("no target language choosen");
				return ;
			}	
		} catch (ParseException e) {
			e.printStackTrace();
		}	
	}




	private static Options createOptions() {
		Options out = new Options();
		
		Option incDir = new Option("i", true, "Directory that contains included files");
		incDir.setLongOpt("includeDirectory");
		incDir.setArgName("dir");
		incDir.setType("String");
		out.addOption(incDir);
		
		
		Option help = new Option("h", false, "Print this help");
		help.setLongOpt("help");
		out.addOption(help);
				
		{	
			Option genJava = new Option("j", false, "Generate Java Bindings for MORA");
				genJava.setLongOpt("generateJava");
			out.addOption(genJava);			
			Option outJava = new Option("jdir", true, "Outputdirectory for generated java files");
				outJava.setArgName("dir");
				outJava.setLongOpt("javaOutputDirectory");
				outJava.setType("String");
				out.addOption(outJava);
		}
		
		{	
			Option cppJava = new Option("cpp", false, "Generate C++ Bindings for MORA");
				cppJava.setLongOpt("generateCpp");
			out.addOption(cppJava);			
			Option cppOut = new Option("cppdir", true, "Outputdirectory for generated C++ files");
				cppOut.setArgName("cppdir");
				cppOut.setLongOpt("cppOutputDirectory");
				cppOut.setType("String");
				out.addOption(cppOut);
		}
		
		{	
			Option cppJava = new Option("plain_cpp", false, "Generate Plain C++ Files");
				cppJava.setLongOpt("generatePlainCpp");
			out.addOption(cppJava);			
			Option cppOut = new Option("plain_cppdir", true, "Outputdirectory for generated C++ files");
				cppOut.setArgName("plain_cppdir");
				cppOut.setLongOpt("plain_cppOutputDirectory");
				cppOut.setType("String");
				out.addOption(cppOut);
		}
		
		{			
			Option genCS = new Option("cs", false, "Generate CSharp (C#) Bindings for MORA");
				genCS.setLongOpt("generateCSharp");
				out.addOption(genCS);
			Option outCS = new Option("csdir", true, "Outputdirectory for generated C# files");
				outCS.setArgName("dir");
				outCS.setLongOpt("csharpOutputDirectory");
				outCS.setType("String");
				out.addOption(outCS);
				
			Option unitySerializeable = new Option("unity", false, "Generate Annotations for Unity, e.g. serializeable for structs, ...");
				out.addOption(unitySerializeable);
		}
		
		return out;
	}



	@Inject
	private Provider<ResourceSet> resourceSetProvider;

	@Inject
	private IResourceValidator validator;

	@Inject 
	private JavaIoFileSystemAccess fileAccess;

	

	private void runGenerator(File file, CommandLine cmd) {
		// Load the resource
		ResourceSet set = resourceSetProvider.get();
		Resource resource = set.getResource(URI.createFileURI(file.getAbsolutePath()), true);
		
		if (cmd.hasOption("i")) {
			String strIncludeDir = cmd.getOptionValue("i");
			File includeDir;
			if (strIncludeDir != null && strIncludeDir.isEmpty() == false && (includeDir = new File(strIncludeDir)).exists()) {
				File[] includeFiles = includeDir.listFiles(new FileFilter() {					
					@Override
					public boolean accept(File pathname) {
						return pathname.isDirectory() || pathname.getName().endsWith(".mora");
					}
				});
				for (File f : includeFiles)
					set.getResource(URI.createFileURI(f.getAbsolutePath()), true);
			}else {
				System.err.println("invalid include directory: " + strIncludeDir);
			}
		}
	
		// Validate the resource
		List<Issue> list = validator.validate(resource, CheckMode.ALL, CancelIndicator.NullImpl);
		if (!list.isEmpty()) {
			for (Issue issue : list) {
				System.err.println(issue);
			}
			return;
		}
		
		String fn = cmd.hasOption("fn") ? cmd.getOptionValue("fn") : null;
		if (cmd.hasOption("j")) {
			generateJava(resource, cmd);
		}
		if (cmd.hasOption("cs"))
			generateCSharp(resource, cmd);
		if (cmd.hasOption("cpp"))
			generateCpp(resource, cmd);
		if (cmd.hasOption("plain_cpp"))
			generatePlainCpp(resource, cmd);
	}
	
	private void generatePlainCpp(Resource resource, CommandLine cmd) {
		File outDir = new File(cmd.getOptionValue("plain_cppdir", "./gen/cpp"));
		fileAccess.setOutputPath(outDir.getAbsolutePath());
		
		CppPlainGenerator cppGen = new CppPlainGenerator();
		
		GeneratorContext context = new GeneratorContext();
		context.setCancelIndicator(CancelIndicator.NullImpl);
		
		cppGen.beforeGenerate(resource, fileAccess, context);
		cppGen.doGenerate(resource, fileAccess, context);
		cppGen.afterGenerate(resource, fileAccess, context);
		
		System.out.println("Finish C++ generation");
	}
	
	private void generateCpp(Resource resource, CommandLine cmd) {
		File outDir = new File(cmd.getOptionValue("cppdir", "./gen/cpp"));
		fileAccess.setOutputPath(outDir.getAbsolutePath());
		
		CppGenerator cppGen = new CppGenerator();
		
		GeneratorContext context = new GeneratorContext();
		context.setCancelIndicator(CancelIndicator.NullImpl);
		
		cppGen.beforeGenerate(resource, fileAccess, context);
		cppGen.doGenerate(resource, fileAccess, context);
		cppGen.afterGenerate(resource, fileAccess, context);
		
		System.out.println("Finish C++ generation");
	}
	
	private void generateJava(Resource resource, CommandLine cmd) {
		File outDir = new File(cmd.getOptionValue("jdir", "./gen/java"));
		fileAccess.setOutputPath(outDir.getAbsolutePath());
		
		JavaGenerator jgen = new JavaGenerator();
		
		GeneratorContext context = new GeneratorContext();
		context.setCancelIndicator(CancelIndicator.NullImpl);
		
		jgen.beforeGenerate(resource, fileAccess, context);
		jgen.doGenerate(resource, fileAccess, context);
		jgen.afterGenerate(resource, fileAccess, context);
		
		System.out.println("Finish Java generation");
	}
	
	
	private void generateCSharp(Resource resource, CommandLine cmd) {
		File outDir = new File(cmd.getOptionValue("csdir", "./gen/csharp"));
		fileAccess.setOutputPath(outDir.getAbsolutePath());
		
		boolean generateForUnity = cmd.hasOption("unity");
		CSharpOptions csOpt = new CSharpOptions(cmd.getOptionValue("csns", ""), generateForUnity);
		CSharpGenerator csGen = new CSharpGenerator(csOpt);
		
		GeneratorContext context = new GeneratorContext();
		context.setCancelIndicator(CancelIndicator.NullImpl);
		
		csGen.beforeGenerate(resource, fileAccess, context);
		csGen.doGenerate(resource, fileAccess, context);
		csGen.afterGenerate(resource, fileAccess, context);
		
		System.out.println("Finish C# generation");
	}




//	protected void runGenerator(String string) {
//		// Load the resource
//		ResourceSet set = resourceSetProvider.get();
//		Resource resource = set.getResource(URI.createFileURI(string), true);
//
//		// Validate the resource
//		List<Issue> list = validator.validate(resource, CheckMode.ALL, CancelIndicator.NullImpl);
//		if (!list.isEmpty()) {
//			for (Issue issue : list) {
//				System.err.println(issue);
//			}
//			return;
//		}
//
//		// Configure and start the generator
//		fileAccess.setOutputPath("src-gen/");
//		GeneratorContext context = new GeneratorContext();
//		context.setCancelIndicator(CancelIndicator.NullImpl);
//		generator.generate(resource, fileAccess, context);
//
//		System.out.println("Code generation finished.");
//	}
}
